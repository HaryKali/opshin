URLS=[
"opshin/index.html",
"opshin/bridge.html",
"opshin/typed_ast.html",
"opshin/tests/index.html",
"opshin/tests/test_builtins.html",
"opshin/tests/utils.html",
"opshin/tests/test_hashlib.html",
"opshin/tests/test_misc.html",
"opshin/tests/test_ops.html",
"opshin/tests/test_ledger/index.html",
"opshin/tests/test_ledger/test_interval.html",
"opshin/tests/test_ledger/test_api_v2.html",
"opshin/tests/test_std/index.html",
"opshin/tests/test_std/test_math.html",
"opshin/tests/test_std/test_integrity.html",
"opshin/tests/test_std/test_fractions.html",
"opshin/tests/test_std/test_bitmap.html",
"opshin/tests/test_stdlib.html",
"opshin/fun_impls.html",
"opshin/builder.html",
"opshin/ledger/index.html",
"opshin/ledger/api_v2.html",
"opshin/ledger/interval.html",
"opshin/types.html",
"opshin/optimize/index.html",
"opshin/optimize/optimize_remove_pass.html",
"opshin/util.html",
"opshin/optimize/optimize_remove_comments.html",
"opshin/optimize/optimize_remove_deadvars.html",
"opshin/optimize/optimize_const_folding.html",
"opshin/compiler.html",
"opshin/rewrite/index.html",
"opshin/rewrite/rewrite_cast_condition.html",
"opshin/rewrite/rewrite_remove_type_stuff.html",
"opshin/rewrite/rewrite_import_typing.html",
"opshin/rewrite/rewrite_inject_builtin_constr.html",
"opshin/rewrite/rewrite_import_dataclasses.html",
"opshin/rewrite/rewrite_subscript38.html",
"opshin/rewrite/rewrite_scoping.html",
"opshin/rewrite/rewrite_augassign.html",
"opshin/rewrite/rewrite_import_integrity_check.html",
"opshin/rewrite/rewrite_forbidden_overwrites.html",
"opshin/rewrite/rewrite_inject_builtins.html",
"opshin/rewrite/rewrite_import_plutusdata.html",
"opshin/rewrite/rewrite_import_uplc_builtins.html",
"opshin/rewrite/rewrite_import_hashlib.html",
"opshin/rewrite/rewrite_tuple_assign.html",
"opshin/rewrite/rewrite_comparison_chaining.html",
"opshin/rewrite/rewrite_forbidden_return.html",
"opshin/rewrite/rewrite_import.html",
"opshin/rewrite/rewrite_orig_name.html",
"opshin/std/index.html",
"opshin/std/integrity.html",
"opshin/std/builtins.html",
"opshin/std/bitmap.html",
"opshin/std/math.html",
"opshin/std/hashlib.html",
"opshin/std/fractions.html",
"opshin/type_inference.html",
"opshin/prelude.html"
];
INDEX=[
{
"ref":"opshin",
"url":0,
"doc":"    opshin                   > You are building what you want. Why not also build  how you want? This is an implementation of smart contracts for Cardano which are written in a strict subset of valid Python. The general philosophy of this project is to write a compiler that ensure the following: If the program compiles then: 1. it is a valid Python program 2. the output running it with python is the same as running it on-chain.  Why opshin? - 100% valid Python. Leverage the existing tool stack for Python, syntax highlighting, linting, debugging, unit-testing, [property-based testing](https: hypothesis.readthedocs.io/), [verification](https: github.com/marcoeilers/nagini) - Intuitive. Just like Python. - Flexible. Imperative, functional, the way you want it. - Efficient & Secure. Static type inference ensures strict typing and optimized code  Getting Started  OpShin Pioneer Program Check out the [opshin-pioneer-program]( https: github.com/OpShin/opshin-pioneer-program) for a host of educational example contracts, test cases and off-chain code.  Example repository Check out the [opshin-starter-kit]( https: github.com/OpShin/opshin-starter-kit) repository for a quick start in setting up a development environment and compiling some sample contracts yourself. You can replace the contracts in your local copy of the repository with code from the  examples section here to start exploring different contracts.  Developer Community and Questions This repository contains a discussions page. Feel free to open up a new discussion with questions regarding development using opshin and using certain features. Others may be able to help you and will also benefit from the previously shared questions. Check out the community [here](https: github.com/OpShin/opshin/discussions) You can also chat with other developers [in the welcoming discord community](https: discord.gg/umR3A2g4uw) of OpShin > Help us improve OpShin by [participating in this survey!](https: forms.gle/KdzYYeeiWCwMTHsX9)  Installation Install Python 3.8, 3.9, 3.10 or 3.11. Then run   python3 -m pip install opshin    Writing a Smart Contract A short non-complete introduction in starting to write smart contracts follows. 1. Make sure you understand EUTxOs, Addresses, Validators etc on Cardano. [There is a wonderful crashcourse by @KtorZ](https: aiken-lang.org/fundamentals/eutxo). The contract will work on these concepts 2. Make sure you understand python. opshin works like python and uses python. There are tons of tutorials for python, choose what suits you best. 3. Make sure your contract is valid python and the types check out. Write simple contracts first and run them using  opshin eval to get a feeling for how they work. 4. Make sure your contract is valid opshin code. Run  opshin compile and look at the compiler erros for guidance along what works and doesn't work and why. 5. Dig into the [ examples ](https: github.com/OpShin/opshin/tree/main/examples) to understand common patterns. Check out the [ prelude ](https: opshin.opshin.dev/opshin/prelude.html) for understanding how the Script Context is structured and how complex datums are defined. 6. Check out the [sample repository](https: github.com/OpShin/opshin-starter-kit) to find a sample setup for developing your own contract. In summary, a smart contract in opshin is defined by the function  validator in your contract file. The function validates that a specific value can be spent, minted, burned, withdrawn etc, depending on where it is invoked/used as a credential. If the function fails (i.e. raises an error of any kind such as a  KeyError or  AssertionError ) the validation is denied, and the funds can not be spent, minted, burned etc. > There is a subtle difference here in comparison to most other Smart Contract languages. > In opshin a validator may return anything (in particular also  False ) - as long as it does not fail, the execution is considered valid. > This is more similar to how contracts in Solidity always pass, unless they run out of gas or hit an error. > So make sure to  assert what you want to ensure to hold for validation! A simple contract called the \"Gift Contract\" verifies that only specific wallets can withdraw money. They are authenticated by a signature. If you don't understand what a pubkeyhash is and how this validates anything, check out [this gentle introduction into Cardanos EUTxO](https: aiken-lang.org/fundamentals/eutxo). Also see the [tutorial by  pycardano ](https: pycardano.readthedocs.io/en/latest/guides/plutus.html) for explanations on what each of the parameters to the validator means and how to build transactions with the contract.   from opshin.prelude import  @dataclass() class WithdrawDatum(PlutusData): pubkeyhash: bytes def validator(datum: WithdrawDatum, redeemer: None, context: ScriptContext) -> None: sig_present = False for s in context.tx_info.signatories: if datum.pubkeyhash  s: sig_present = True assert sig_present, \"Required signature missing\"   All contracts written in opshin are 100% valid python. Minting policies expect only a redeemer and script context as argument. Check out the [Architecture guide](https: github.com/OpShin/opshin/blob/main/ARCHITECTURE.md minting-policy -spending-validator-double-function) for details on how to write double functioning contracts. The [ examples ](https: github.com/OpShin/opshin/blob/main/examples) folder contains more examples. Also check out the [opshin-pioneer-program]( https: github.com/OpShin/opshin-pioneer-program) and [opshin-starter-kit]( https: github.com/OpShin/opshin-starter-kit) repo.  Compiling Write your program in python. You may start with the content of  examples . Arguments to scripts are passed in as Plutus Data objects in JSON notation. You can run any of the following commands    Evaluate script in Python - this can be used to make sure there are no obvious errors opshin eval spending examples/smart_contracts/assert_sum.py \"{\\\"int\\\": 4}\" \"{\\\"int\\\": 38}\" d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87980d87a80ffd8799fd87b80d87a80ffff80a1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820746957f0eb57f2b11119684e611a98f373afea93473fefbb7632d579af2f6259ffffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff  Compile script to 'uplc', the Cardano Smart Contract assembly opshin compile spending examples/smart_contracts/assert_sum.py   Furthermore, you can add a shebang to the first line of the python file to indicate that it represents an opshin smart contract. You can choose from the following options: - a general shebang:  !opshin , which represents  opshin eval any - or a more specific purpose:  !/usr/bin/env -S opshin eval minting By doing so, you can transform your python file to an executable:  chmod +x your_file.py and execute it with  ./your_file.py , which will run  opshin eval any ./your_file.py under the hood.  Deploying The deploy process generates all artifacts required for usage with common libraries like [pycardano](https: github.com/Python-Cardano/pycardano), [lucid](https: github.com/spacebudz/lucid) and the [cardano-cli](https: github.com/input-output-hk/cardano-node).    Automatically generate all artifacts needed for using this contract opshin build spending examples/smart_contracts/assert_sum.py   See the [tutorial by  pycardano ](https: pycardano.readthedocs.io/en/latest/guides/plutus.html) for explanations how to build transactions with  opshin contracts.  API for Smart Contracts The python interface offers a simple API to compile, load, apply parameters and evaluate smart contracts.   from opshin.builder import   Build a validator script from a python file that contains a validator function contract = build(\"path/to/contract.py\")  You can apply parameters to the contract during compilation contract = build(\"path/to/contract.py\", arg1, arg2, arg3)  Store the compilation artifacts in a folder contract.dump(\"path/to/store\")  You can also load a compiled contract from a path contract = load(\"path/to/store\")  And apply parameters after loading a contract contract = contract.apply_parameters(arg1, arg2, arg3)  The artifacts contain the compiled script, the policy ID and the addresses and blueprint contract_addr = contract.mainnet_addr contract_blueprint = contract.blueprint    The small print _Not every valid python program is a valid smart contract_. Not all language features of python will or can be supported. The reasons are mainly of practical nature (i.e. we can't infer types when functions like  eval are allowed). Specifically, only a pure subset of python is allowed. Further, only immutable objects may be generated. For your program to be accepted, make sure to only make use of language constructs supported by the compiler. You will be notified of which constructs are not supported when trying to compile. You can also make use of the built-in linting command and check it for example with the following command:   opshin lint spending examples/smart_contracts/assert_sum.py    Name > Eopsin (Korean: \uc5c5\uc2e0; Hanja: \u696d\u795e) is the goddess of the storage and wealth in Korean mythology and shamanism. > [ .] Eopsin was believed to be a pitch-black snake that had ears.  1 (https: en.wikipedia.org/wiki/Eopsin) Since this project tries to merge Python (a large serpent) and Pluto/Plutus (Greek wealth gods), the name appears fitting. The name e_opsin is pronounced _op-shin_. e  Debugging artefacts For debugging purposes, you can also run    Compile script to 'uplc', and evaluate the script in UPLC (for debugging purposes) opshin eval_uplc spending examples/smart_contracts/assert_sum.py \"{\\\"int\\\": 4}\" \"{\\\"int\\\": 38}\" d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87980d87a80ffd8799fd87b80d87a80ffff80a1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820746957f0eb57f2b11119684e611a98f373afea93473fefbb7632d579af2f6259ffffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff  Compile script to 'pluto', an intermediate language (for debugging purposes) opshin compile_pluto spending examples/smart_contracts/assert_sum.py    Contributing  Developing and Technical Documentation Generally, all contributions on the code side are very welcome. To get an overview over the architecture and idea behind OpShin, check out [the Technical Documentation](./ARCHITECTURE.md).  Sponsoring You can sponsor the development of opshin through GitHub or [Patreon](https: patreon.com/OpShin) or just by sending ADA. Drop me a message on social media and let me know what it is for. -  Patreon Support OpShin at [Patreon](https: patreon.com/OpShin) to enjoy member benefits! -  GitHub Sponsor the developers of this project through the button \"Sponsor\" next to them -  ADA Donation in ADA can be submitted to  $opshin or  addr1qyz3vgd5xxevjy2rvqevz9n7n7dney8n6hqggp23479fm6vwpj9clsvsf85cd4xc59zjztr5zwpummwckmzr2myjwjns74lhmr .  Supporters             The main sponsor of this project is [Inversion](https: inversion.dev/cardano/). Here is a word from them! > At Inversion, we pride ourselves on our passion for life and our ability to create exceptional software solutions for our clients. Our team of experts, with over a century of cumulative experience, is dedicated to harnessing the power of the Cardano blockchain to bring innovative and scalable decentralized applications to life. We've successfully built applications for NFT management, staking and delegation, chain data monitoring, analytics, and web3 integrations, as well as countless non-blockchain systems. With a focus on security, transparency, and sustainability, our team is excited to contribute to the Cardano ecosystem, pushing the boundaries of decentralized technologies to improve lives worldwide. Trust Inversion to be your go-to partner for robust, effective, and forward-thinking solutions, whether blockchain based, traditional systems, or a mix of the two. They have recently started a podcast, called \"Africa On Chain\", which you can check out here: https: www.youtube.com/@africaonchain"
},
{
"ref":"opshin.bridge",
"url":1,
"doc":"Bridging tools between uplc and opshin"
},
{
"ref":"opshin.bridge.to_uplc_builtin",
"url":1,
"doc":"",
"func":1
},
{
"ref":"opshin.bridge.to_python",
"url":1,
"doc":"",
"func":1
},
{
"ref":"opshin.bridge.wraps_builtin",
"url":1,
"doc":"",
"func":1
},
{
"ref":"opshin.typed_ast",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAST",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAST.typ",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedexpr",
"url":2,
"doc":"expr = BoolOp(boolop op, expr values) | NamedExpr(expr target, expr value) | BinOp(expr left, operator op, expr right) | UnaryOp(unaryop op, expr operand) | Lambda(arguments args, expr body) | IfExp(expr test, expr body, expr orelse) | Dict(expr keys, expr values) | Set(expr elts) | ListComp(expr elt, comprehension generators) | SetComp(expr elt, comprehension generators) | DictComp(expr key, expr value, comprehension generators) | GeneratorExp(expr elt, comprehension generators) | Await(expr value) | Yield(expr? value) | YieldFrom(expr value) | Compare(expr left, cmpop ops, expr comparators) | Call(expr func, expr args, keyword keywords) | FormattedValue(expr value, int conversion, expr? format_spec) | JoinedStr(expr values) | Constant(constant value, string? kind) | Attribute(expr value, identifier attr, expr_context ctx) | Subscript(expr value, expr slice, expr_context ctx) | Starred(expr value, expr_context ctx) | Name(identifier id, expr_context ctx) | List(expr elts, expr_context ctx) | Tuple(expr elts, expr_context ctx) | Slice(expr? lower, expr? upper, expr? step)"
},
{
"ref":"opshin.typed_ast.typedexpr.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.typedstmt",
"url":2,
"doc":"stmt = FunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment) | AsyncFunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment) | ClassDef(identifier name, expr bases, keyword keywords, stmt body, expr decorator_list) | Return(expr? value) | Delete(expr targets) | Assign(expr targets, expr value, string? type_comment) | AugAssign(expr target, operator op, expr value) | AnnAssign(expr target, expr annotation, expr? value, int simple) | For(expr target, expr iter, stmt body, stmt orelse, string? type_comment) | AsyncFor(expr target, expr iter, stmt body, stmt orelse, string? type_comment) | While(expr test, stmt body, stmt orelse) | If(expr test, stmt body, stmt orelse) | With(withitem items, stmt body, string? type_comment) | AsyncWith(withitem items, stmt body, string? type_comment) | Match(expr subject, match_case cases) | Raise(expr? exc, expr? cause) | Try(stmt body, excepthandler handlers, stmt orelse, stmt finalbody) | Assert(expr test, expr? msg) | Import(alias names) | ImportFrom(identifier? module, alias names, int? level) | Global(identifier names) | Nonlocal(identifier names) | Expr(expr value) | Pass | Break | Continue"
},
{
"ref":"opshin.typed_ast.typedstmt.typ",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedarg",
"url":2,
"doc":"arg(identifier arg, expr? annotation, string? type_comment)"
},
{
"ref":"opshin.typed_ast.typedarguments",
"url":2,
"doc":"arguments(arg posonlyargs, arg args, arg? vararg, arg kwonlyargs, expr kw_defaults, arg? kwarg, expr defaults)"
},
{
"ref":"opshin.typed_ast.typedarguments.args",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedarguments.vararg",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedarguments.kwonlyargs",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedarguments.kw_defaults",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedarguments.kwarg",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedarguments.defaults",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedModule",
"url":2,
"doc":"stmt = FunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment) | AsyncFunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment) | ClassDef(identifier name, expr bases, keyword keywords, stmt body, expr decorator_list) | Return(expr? value) | Delete(expr targets) | Assign(expr targets, expr value, string? type_comment) | AugAssign(expr target, operator op, expr value) | AnnAssign(expr target, expr annotation, expr? value, int simple) | For(expr target, expr iter, stmt body, stmt orelse, string? type_comment) | AsyncFor(expr target, expr iter, stmt body, stmt orelse, string? type_comment) | While(expr test, stmt body, stmt orelse) | If(expr test, stmt body, stmt orelse) | With(withitem items, stmt body, string? type_comment) | AsyncWith(withitem items, stmt body, string? type_comment) | Match(expr subject, match_case cases) | Raise(expr? exc, expr? cause) | Try(stmt body, excepthandler handlers, stmt orelse, stmt finalbody) | Assert(expr test, expr? msg) | Import(alias names) | ImportFrom(identifier? module, alias names, int? level) | Global(identifier names) | Nonlocal(identifier names) | Expr(expr value) | Pass | Break | Continue"
},
{
"ref":"opshin.typed_ast.TypedModule.body",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFunctionDef",
"url":2,
"doc":"FunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment)"
},
{
"ref":"opshin.typed_ast.TypedFunctionDef.body",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFunctionDef.args",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedIf",
"url":2,
"doc":"If(expr test, stmt body, stmt orelse)"
},
{
"ref":"opshin.typed_ast.TypedIf.test",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedIf.body",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedIf.orelse",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedReturn",
"url":2,
"doc":"Return(expr? value)"
},
{
"ref":"opshin.typed_ast.TypedReturn.value",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedExpression",
"url":2,
"doc":"stmt = FunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment) | AsyncFunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment) | ClassDef(identifier name, expr bases, keyword keywords, stmt body, expr decorator_list) | Return(expr? value) | Delete(expr targets) | Assign(expr targets, expr value, string? type_comment) | AugAssign(expr target, operator op, expr value) | AnnAssign(expr target, expr annotation, expr? value, int simple) | For(expr target, expr iter, stmt body, stmt orelse, string? type_comment) | AsyncFor(expr target, expr iter, stmt body, stmt orelse, string? type_comment) | While(expr test, stmt body, stmt orelse) | If(expr test, stmt body, stmt orelse) | With(withitem items, stmt body, string? type_comment) | AsyncWith(withitem items, stmt body, string? type_comment) | Match(expr subject, match_case cases) | Raise(expr? exc, expr? cause) | Try(stmt body, excepthandler handlers, stmt orelse, stmt finalbody) | Assert(expr test, expr? msg) | Import(alias names) | ImportFrom(identifier? module, alias names, int? level) | Global(identifier names) | Nonlocal(identifier names) | Expr(expr value) | Pass | Break | Continue"
},
{
"ref":"opshin.typed_ast.TypedExpression.body",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedCall",
"url":2,
"doc":"Call(expr func, expr args, keyword keywords)"
},
{
"ref":"opshin.typed_ast.TypedCall.func",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedCall.args",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedCall.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedExpr",
"url":2,
"doc":"Expr(expr value)"
},
{
"ref":"opshin.typed_ast.TypedExpr.value",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAssign",
"url":2,
"doc":"Assign(expr targets, expr value, string? type_comment)"
},
{
"ref":"opshin.typed_ast.TypedAssign.targets",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAssign.value",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedClassDef",
"url":2,
"doc":"ClassDef(identifier name, expr bases, keyword keywords, stmt body, expr decorator_list)"
},
{
"ref":"opshin.typed_ast.TypedClassDef.class_typ",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAnnAssign",
"url":2,
"doc":"AnnAssign(expr target, expr annotation, expr? value, int simple)"
},
{
"ref":"opshin.typed_ast.TypedAnnAssign.target",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAnnAssign.annotation",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAnnAssign.value",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedWhile",
"url":2,
"doc":"While(expr test, stmt body, stmt orelse)"
},
{
"ref":"opshin.typed_ast.TypedWhile.test",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedWhile.body",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedWhile.orelse",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFor",
"url":2,
"doc":"For(expr target, expr iter, stmt body, stmt orelse, string? type_comment)"
},
{
"ref":"opshin.typed_ast.TypedFor.target",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFor.iter",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFor.body",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFor.orelse",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedPass",
"url":2,
"doc":"Pass"
},
{
"ref":"opshin.typed_ast.TypedName",
"url":2,
"doc":"Name(identifier id, expr_context ctx)"
},
{
"ref":"opshin.typed_ast.TypedName.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedConstant",
"url":2,
"doc":"Constant(constant value, string? kind)"
},
{
"ref":"opshin.typed_ast.TypedTuple",
"url":2,
"doc":"Tuple(expr elts, expr_context ctx)"
},
{
"ref":"opshin.typed_ast.TypedTuple.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedList",
"url":2,
"doc":"List(expr elts, expr_context ctx)"
},
{
"ref":"opshin.typed_ast.TypedList.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.typedcomprehension",
"url":2,
"doc":"expr = BoolOp(boolop op, expr values) | NamedExpr(expr target, expr value) | BinOp(expr left, operator op, expr right) | UnaryOp(unaryop op, expr operand) | Lambda(arguments args, expr body) | IfExp(expr test, expr body, expr orelse) | Dict(expr keys, expr values) | Set(expr elts) | ListComp(expr elt, comprehension generators) | SetComp(expr elt, comprehension generators) | DictComp(expr key, expr value, comprehension generators) | GeneratorExp(expr elt, comprehension generators) | Await(expr value) | Yield(expr? value) | YieldFrom(expr value) | Compare(expr left, cmpop ops, expr comparators) | Call(expr func, expr args, keyword keywords) | FormattedValue(expr value, int conversion, expr? format_spec) | JoinedStr(expr values) | Constant(constant value, string? kind) | Attribute(expr value, identifier attr, expr_context ctx) | Subscript(expr value, expr slice, expr_context ctx) | Starred(expr value, expr_context ctx) | Name(identifier id, expr_context ctx) | List(expr elts, expr_context ctx) | Tuple(expr elts, expr_context ctx) | Slice(expr? lower, expr? upper, expr? step)"
},
{
"ref":"opshin.typed_ast.typedcomprehension.target",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedcomprehension.iter",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedcomprehension.ifs",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.typedcomprehension.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedListComp",
"url":2,
"doc":"ListComp(expr elt, comprehension generators)"
},
{
"ref":"opshin.typed_ast.TypedListComp.generators",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedListComp.elt",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedListComp.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedFormattedValue",
"url":2,
"doc":"FormattedValue(expr value, int conversion, expr? format_spec)"
},
{
"ref":"opshin.typed_ast.TypedFormattedValue.value",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFormattedValue.conversion",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFormattedValue.format_spec",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedFormattedValue.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedJoinedStr",
"url":2,
"doc":"JoinedStr(expr values)"
},
{
"ref":"opshin.typed_ast.TypedJoinedStr.values",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedJoinedStr.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedDict",
"url":2,
"doc":"Dict(expr keys, expr values)"
},
{
"ref":"opshin.typed_ast.TypedDict.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedIfExp",
"url":2,
"doc":"stmt = FunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment) | AsyncFunctionDef(identifier name, arguments args, stmt body, expr decorator_list, expr? returns, string? type_comment) | ClassDef(identifier name, expr bases, keyword keywords, stmt body, expr decorator_list) | Return(expr? value) | Delete(expr targets) | Assign(expr targets, expr value, string? type_comment) | AugAssign(expr target, operator op, expr value) | AnnAssign(expr target, expr annotation, expr? value, int simple) | For(expr target, expr iter, stmt body, stmt orelse, string? type_comment) | AsyncFor(expr target, expr iter, stmt body, stmt orelse, string? type_comment) | While(expr test, stmt body, stmt orelse) | If(expr test, stmt body, stmt orelse) | With(withitem items, stmt body, string? type_comment) | AsyncWith(withitem items, stmt body, string? type_comment) | Match(expr subject, match_case cases) | Raise(expr? exc, expr? cause) | Try(stmt body, excepthandler handlers, stmt orelse, stmt finalbody) | Assert(expr test, expr? msg) | Import(alias names) | ImportFrom(identifier? module, alias names, int? level) | Global(identifier names) | Nonlocal(identifier names) | Expr(expr value) | Pass | Break | Continue"
},
{
"ref":"opshin.typed_ast.TypedIfExp.test",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedIfExp.body",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedIfExp.orelse",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedCompare",
"url":2,
"doc":"Compare(expr left, cmpop ops, expr comparators)"
},
{
"ref":"opshin.typed_ast.TypedCompare.left",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedCompare.ops",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedCompare.comparators",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedCompare.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedBinOp",
"url":2,
"doc":"BinOp(expr left, operator op, expr right)"
},
{
"ref":"opshin.typed_ast.TypedBinOp.left",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedBinOp.right",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedBinOp.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedBoolOp",
"url":2,
"doc":"BoolOp(boolop op, expr values)"
},
{
"ref":"opshin.typed_ast.TypedBoolOp.values",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedBoolOp.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedUnaryOp",
"url":2,
"doc":"UnaryOp(unaryop op, expr operand)"
},
{
"ref":"opshin.typed_ast.TypedUnaryOp.operand",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedUnaryOp.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedSubscript",
"url":2,
"doc":"Subscript(expr value, expr slice, expr_context ctx)"
},
{
"ref":"opshin.typed_ast.TypedSubscript.value",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedSubscript.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedAttribute",
"url":2,
"doc":"Attribute(expr value, identifier attr, expr_context ctx)"
},
{
"ref":"opshin.typed_ast.TypedAttribute.value",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAttribute.pos",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAttribute.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.typed_ast.TypedAssert",
"url":2,
"doc":"Assert(expr test, expr? msg)"
},
{
"ref":"opshin.typed_ast.TypedAssert.test",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.TypedAssert.msg",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.RawPlutoExpr",
"url":2,
"doc":"expr = BoolOp(boolop op, expr values) | NamedExpr(expr target, expr value) | BinOp(expr left, operator op, expr right) | UnaryOp(unaryop op, expr operand) | Lambda(arguments args, expr body) | IfExp(expr test, expr body, expr orelse) | Dict(expr keys, expr values) | Set(expr elts) | ListComp(expr elt, comprehension generators) | SetComp(expr elt, comprehension generators) | DictComp(expr key, expr value, comprehension generators) | GeneratorExp(expr elt, comprehension generators) | Await(expr value) | Yield(expr? value) | YieldFrom(expr value) | Compare(expr left, cmpop ops, expr comparators) | Call(expr func, expr args, keyword keywords) | FormattedValue(expr value, int conversion, expr? format_spec) | JoinedStr(expr values) | Constant(constant value, string? kind) | Attribute(expr value, identifier attr, expr_context ctx) | Subscript(expr value, expr slice, expr_context ctx) | Starred(expr value, expr_context ctx) | Name(identifier id, expr_context ctx) | List(expr elts, expr_context ctx) | Tuple(expr elts, expr_context ctx) | Slice(expr? lower, expr? upper, expr? step)"
},
{
"ref":"opshin.typed_ast.RawPlutoExpr.typ",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.RawPlutoExpr.expr",
"url":2,
"doc":""
},
{
"ref":"opshin.typed_ast.RawPlutoExpr.typechecks",
"url":2,
"doc":"Successful typechecks if this expression evaluates to True",
"func":1
},
{
"ref":"opshin.tests",
"url":3,
"doc":""
},
{
"ref":"opshin.tests.test_builtins",
"url":4,
"doc":""
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest",
"url":4,
"doc":"A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes:  failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'.  longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in  addition to any explicit message passed.  maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name."
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_all",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_any",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_abs",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bytes_int_list",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bytes_int",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bytes_bytes",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_chr",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_hex",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_int_string",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_int_bool",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_int_int",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_len_bytestring",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_len_lists",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_len_dicts",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_len_tuples",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_max",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_min",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_pow",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_oct",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_range",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_str_int",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_str_bool",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_sum",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_reversed",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bool_constr_int",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bool_constr_str",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bool_constr_bytes",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bool_constr_none",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bool_constr_bool",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bool_constr_list",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_bool_constr_dict",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_builtins.BuiltinTest.test_print_compile",
"url":4,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.utils",
"url":5,
"doc":""
},
{
"ref":"opshin.tests.utils.Unit",
"url":5,
"doc":"Unit()"
},
{
"ref":"opshin.tests.utils.Unit.CONSTR_ID",
"url":5,
"doc":""
},
{
"ref":"opshin.tests.utils.eval_uplc",
"url":5,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.utils.eval_uplc_value",
"url":5,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_hashlib",
"url":6,
"doc":""
},
{
"ref":"opshin.tests.test_hashlib.test_sha256",
"url":6,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_hashlib.test_sha3_256",
"url":6,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_hashlib.test_blake2b",
"url":6,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.fib",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.A",
"url":7,
"doc":"A(foo: int)"
},
{
"ref":"opshin.tests.test_misc.A.foo",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.A.CONSTR_ID",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.B",
"url":7,
"doc":"B(foobar: int, bar: int)"
},
{
"ref":"opshin.tests.test_misc.B.foobar",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.B.bar",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.B.CONSTR_ID",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.MiscTest",
"url":7,
"doc":"A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes:  failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'.  longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in  addition to any explicit message passed.  maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name."
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_assert_sum_contract_succeed",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_assert_sum_contract_fail",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_mult_for",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_mult_for_return",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_mult_while_return",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_sum",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_complex_datum_correct_vals",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_hello_world",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_list_datum_correct_vals",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_showcase",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_fib_iter",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_fib_rec",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_gift_contract_succeed",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_gift_contract_fail",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_recursion_simple",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_recursion_illegal",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_recursion_legal",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_uninitialized_access",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_illegal_bind",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_type_reassignment_function_bound",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_illegal_function_retype",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_datum_cast",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_wrapping_contract_compile",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_dual_use_compile",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_marketplace_compile",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_marketplace_compile_fail",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_parameterized_compile",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_dict_datum",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_dict_datum_wrong",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_removedeadvar_noissue",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_removedeadvar_noissue2",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_removedeadvar_noissue3",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_overopt_removedeadvar",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_opt_shared_var",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_list_expr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_list_expr_not_const",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_dict_expr_not_const",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_redefine_poly_constr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_redefine_constr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_wrap_into_generic_data",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_list_comprehension_even",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_list_comprehension_all",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_union_type_attr_access_all_records",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_union_type_attr_access_all_records_diff_pos",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_union_type_all_records_same_constr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_union_type_attr_access_all_records_same_constr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_union_type_attr_access_maximum_type",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_union_type_attr_anytype",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_typecast_anything_int",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_typecast_int_anything",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_typecast_int_anything_int",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_typecast_anything_int_anything",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_typecast_int_str",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_typecast_int_int",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_zero_ary",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_zero_ary_exec",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_zero_ary_method",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_zero_ary_method_exec",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_zero_ary_method_exec_suc",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_anything",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_no_return_annotation",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_no_parameter_annotation",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_dict_items_values_deconstr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_nested_deconstruction",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_no_return_annotation_no_return",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_opt_unsafe_cast",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_disabled",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_list",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_dict",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_complex",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_plutusdata",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_user_def",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_ifelse",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_for",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_for_target",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_while",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_guaranteed_branch",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_scoping",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_no_scoping",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_repeated_assign",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_math",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_reassign_builtin",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_reassign_builtin_invalid_type",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_ignore_reassignment",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_constant_folding_no_print_eval",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_inner_outer_state_functions",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_inner_outer_state_functions_nonglobal",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_outer_state_change_functions",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_failing_annotated_type",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_access_enclosing_variable_before_def",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_access_local_variable_before_assignment",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_warn_bytestring",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_script_context_str_format_0_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87980d87a80ffd8799fd87b80d87a80ffff80a1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820746957f0eb57f2b11119684e611a98f373afea93473fefbb7632d579af2f6259ffffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_script_context_str_format_1_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87a9f1b000001836ac117d8ffd87a80ffd8799fd87b80d87a80ffff80a1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820797a1e1720b63621c6b185088184cb8e23af6e46b55bd83e7a91024c823a6c2affffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_script_context_str_format_2_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a1401a000f4240d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87a9f1b000001836ac117d8ffd87a80ffd8799fd87b80d87a80ffff9f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffa1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820c17c32f6433ae22c2acaebfb796bbfaee3993ff7ebb58a2bac6b4a3bdd2f6d28ffffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_script_context_str_format",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_uplc_builtin",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_trace_order",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_print_empty",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_cast_bool_ite",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_cast_bool_ite_expr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_cast_bool_while",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_cast_bool_boolops",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_if",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_complex_isinstance_cast_if",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_ifexpr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_while",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_random",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_shortcut_and",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_assert",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_assert_if",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_complex_or",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_complex_or_sameconstr",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_complex_not",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_complex_ifelse",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_complex_or_else",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_complex_and_else",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_complex_and",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_isinstance_cast_shortcut_or",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_uniontype_if",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_if_no_retype_no_plutusdata",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_while_no_retype_no_plutusdata",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_retype_while",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_retype_if_branch_correct",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_retype_while_branch_correct",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_retype_while_wrong_after_iter",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_retype",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_retype_if_primitives",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_in_list",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_comparison_chaining",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_double_import_offset",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_double_import_direct",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_double_import_deep",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_bytearray_alternative",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_ByteString_alternative",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_boolop_chaining",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_wrapping_contract_apply",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_wrapping_contract_dump_load",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_bridge",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_forbidden_overwrite",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_00_examples_dict_datum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_01_examples_inspect_script_context_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_02_examples_datum_cast_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_03_examples_sum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_04_examples_complex_datum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_05_examples_list_datum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_06_examples_hello_world_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_07_examples_mult_for_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_08_examples_list_comprehensions_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_09_examples_fib_rec_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_10_examples_showcase_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_11_examples_fib_iter_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_12_examples_mult_while_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_13_examples_smart_contracts_dual_use_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_14_examples_smart_contracts_simple_script_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_15_examples_smart_contracts_parameterized_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_16_examples_smart_contracts_gift_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_17_examples_smart_contracts_wrapped_token_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_18_examples_smart_contracts_always_true_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_19_examples_smart_contracts_micropayments_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_20_examples_smart_contracts_marketplace_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local_21_examples_smart_contracts_assert_sum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_local",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_00_examples_dict_datum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_01_examples_inspect_script_context_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_02_examples_datum_cast_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_03_examples_sum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_04_examples_complex_datum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_05_examples_list_datum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_06_examples_hello_world_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_07_examples_mult_for_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_08_examples_list_comprehensions_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_09_examples_fib_rec_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_10_examples_showcase_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_11_examples_fib_iter_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_12_examples_mult_while_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_13_examples_smart_contracts_dual_use_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_14_examples_smart_contracts_simple_script_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_15_examples_smart_contracts_parameterized_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_16_examples_smart_contracts_gift_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_17_examples_smart_contracts_wrapped_token_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_18_examples_smart_contracts_always_true_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_19_examples_smart_contracts_micropayments_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_20_examples_smart_contracts_marketplace_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external_21_examples_smart_contracts_assert_sum_py",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_compilation_deterministic_external",
"url":7,
"doc":""
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_illegal",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_in_loop",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_in_for",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_in_if",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_in_if_same_type",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_in_if_missing_return",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_different_return_types_anything",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_different_return_types_while_loop",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_different_return_types_for_loop",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_else_loop_while",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_misc.MiscTest.test_return_else_loop_for",
"url":7,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops",
"url":8,
"doc":""
},
{
"ref":"opshin.tests.test_ops.frozenlist",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.rec_data_strategies",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest",
"url":8,
"doc":"A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes:  failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'.  longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in  addition to any explicit message passed.  maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name."
},
{
"ref":"opshin.tests.test_ops.OpTest.test_and_bool",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_or_bool",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_not_bool",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_usub_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_add_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_sub_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_mul_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_div_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_mod_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_pow_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_add_bytes",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_add_str",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_slice_bytes",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_slice_bytes_lower",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_slice_bytes_upper",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_slice_bytes_full",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_index_bytes",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_index_list",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_slice_list",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_slice_list_lower",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_slice_list_upper",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_slice_list_full",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_in_list_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_in_list_bytes",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_eq_bytes",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_eq_str",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_eq_bool",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_mul_int_str",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_mul_str_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_mul_int_bytes",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_mul_bytes_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_add_list",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_bool",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_str",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_bytes",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_none",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_dataclass",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_multiple",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_tuple_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_tuple_str",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_pair_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_pair_str",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_list_str",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_list_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_dict_int",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ops.OpTest.test_fmt_any",
"url":8,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger",
"url":9,
"doc":""
},
{
"ref":"opshin.tests.test_ledger.test_interval",
"url":10,
"doc":""
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_ordering_compare",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_commutative_compare_extended",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_ordering_compare_extended",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_ordering_compare_lower_bound",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_commutative_lower_bound",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_ordering_compare_upper_bound",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_commutative_compare_upper_bound",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_contains",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_fuzz_make_from",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_fuzz_make_range",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_fuzz_make_to",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_fuzz_compare_extended_helper",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_get_bool",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_make_to_in_make_range",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_interval.test_make_from_in_make_range",
"url":10,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_api_v2",
"url":11,
"doc":""
},
{
"ref":"opshin.tests.test_ledger.test_api_v2.test_script_context_repr_correct_0_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87980d87a80ffd8799fd87b80d87a80ffff80a1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820746957f0eb57f2b11119684e611a98f373afea93473fefbb7632d579af2f6259ffffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":11,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_api_v2.test_script_context_repr_correct_1_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87a9f1b000001836ac117d8ffd87a80ffd8799fd87b80d87a80ffff80a1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820797a1e1720b63621c6b185088184cb8e23af6e46b55bd83e7a91024c823a6c2affffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":11,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_ledger.test_api_v2.test_script_context_repr_correct_2_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a1401a000f4240d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87a9f1b000001836ac117d8ffd87a80ffd8799fd87b80d87a80ffff9f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffa1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820c17c32f6433ae22c2acaebfb796bbfaee3993ff7ebb58a2bac6b4a3bdd2f6d28ffffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":11,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std",
"url":12,
"doc":""
},
{
"ref":"opshin.tests.test_std.test_math",
"url":13,
"doc":""
},
{
"ref":"opshin.tests.test_std.test_math.test_gcd",
"url":13,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_math.test_sign",
"url":13,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_math.test_unsigned_int_from_bytes_big",
"url":13,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_math.test_ceil",
"url":13,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_math.test_floor",
"url":13,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity",
"url":14,
"doc":""
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_0",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_1",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_2",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_3",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_list_0",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_list_1",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_list_2",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_dict_0",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_dict_1",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_dict_2",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_integrity.test_integrity_check_rename",
"url":14,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions",
"url":15,
"doc":""
},
{
"ref":"opshin.tests.test_std.test_fractions.native_fraction_from_oc_fraction",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_add",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_sub",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_neg",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_mul",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_div",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_norm_sign",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_norm",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_ge",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_le",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_lt",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_gt",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_eq",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_floor",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_fractions.test_ceil",
"url":15,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap",
"url":16,
"doc":""
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_init_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.bytes_and_index",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_test_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test__set_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_set_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_reset_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_flip_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_size_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_all_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_any_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_none_bitmap",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_flip_roundtrip",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_set_test",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_std.test_bitmap.test_reset_test",
"url":16,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib",
"url":17,
"doc":""
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest",
"url":17,
"doc":"A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes:  failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'.  longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in  addition to any explicit message passed.  maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name."
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_dict_get",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_dict_subscript",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_dict_keys",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_dict_values",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_dict_items_keys_sum",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_dict_items_values_sum",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_str_encode",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_bytes_decode",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_bytes_hex",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_constant_bytestring",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_constant_integer",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_constant_string",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_constant_unit",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_constant_bool",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_plutusdata_to_cbor",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.tests.test_stdlib.StdlibTest.test_union_to_cbor",
"url":17,
"doc":"",
"func":1
},
{
"ref":"opshin.fun_impls",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.LenImpl",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.LenImpl.type_from_args",
"url":18,
"doc":"",
"func":1
},
{
"ref":"opshin.fun_impls.LenImpl.impl_from_args",
"url":18,
"doc":"",
"func":1
},
{
"ref":"opshin.fun_impls.ReversedImpl",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.ReversedImpl.type_from_args",
"url":18,
"doc":"",
"func":1
},
{
"ref":"opshin.fun_impls.ReversedImpl.impl_from_args",
"url":18,
"doc":"",
"func":1
},
{
"ref":"opshin.fun_impls.PrintImpl",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PrintImpl.type_from_args",
"url":18,
"doc":"",
"func":1
},
{
"ref":"opshin.fun_impls.PrintImpl.impl_from_args",
"url":18,
"doc":"",
"func":1
},
{
"ref":"opshin.fun_impls.PythonBuiltIn",
"url":18,
"doc":"An enumeration."
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.all",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.any",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.abs",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.chr",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.breakpoint",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.hex",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.len",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.max",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.min",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.print",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.pow",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.oct",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.range",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.reversed",
"url":18,
"doc":""
},
{
"ref":"opshin.fun_impls.PythonBuiltIn.sum",
"url":18,
"doc":""
},
{
"ref":"opshin.builder",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.Purpose",
"url":19,
"doc":"An enumeration."
},
{
"ref":"opshin.builder.Purpose.spending",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.Purpose.minting",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.Purpose.rewarding",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.Purpose.certifying",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.Purpose.any",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.Purpose.lib",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract",
"url":19,
"doc":"PlutusContract(contract: pycardano.plutus.PlutusV2Script, datum_type: Optional[Tuple[str, Type[Union[pycardano.plutus.PlutusData, dict, int, bytes, pycardano.serialization.IndefiniteList, pycardano.serialization.RawCBOR, pycardano.plutus.RawPlutusData  = None, redeemer_type: Optional[Tuple[str, Type[Union[pycardano.plutus.PlutusData, dict, int, bytes, pycardano.serialization.IndefiniteList, pycardano.serialization.RawCBOR, pycardano.plutus.RawPlutusData  = None, parameter_types: List[Tuple[str, Type[Union[pycardano.plutus.PlutusData, dict, int, bytes, pycardano.serialization.IndefiniteList, pycardano.serialization.RawCBOR, pycardano.plutus.RawPlutusData  =  , purpose: Iterable[opshin.builder.Purpose] = ( ,), version: Optional[str] = '1.0.0', title: str = 'validator', description: Optional[str] = 'opshin 0.19.0 Smart Contract', license: Optional[str] = None)"
},
{
"ref":"opshin.builder.PlutusContract.contract",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.parameter_types",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.datum_type",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.redeemer_type",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.purpose",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.version",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.title",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.description",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.license",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.cbor",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.cbor_hex",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.script_hash",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.policy_id",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.mainnet_addr",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.testnet_addr",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.plutus_json",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.blueprint",
"url":19,
"doc":""
},
{
"ref":"opshin.builder.PlutusContract.apply_parameter",
"url":19,
"doc":"Returns a new OpShin Contract with the applied parameters",
"func":1
},
{
"ref":"opshin.builder.PlutusContract.dump",
"url":19,
"doc":"",
"func":1
},
{
"ref":"opshin.builder.compile",
"url":19,
"doc":"",
"func":1
},
{
"ref":"opshin.builder.build",
"url":19,
"doc":"Expects a python module and returns the build artifacts from compiling it",
"func":1
},
{
"ref":"opshin.builder.to_plutus_schema",
"url":19,
"doc":"Convert to a dictionary representing a json schema according to CIP 57 Plutus Blueprint Reference of the core structure: https: cips.cardano.org/cips/cip57/ corevocabulary Args:  kwargs: Extra key word arguments to be passed to  json.dumps() Returns: dict: a dict representing the schema of this class.",
"func":1
},
{
"ref":"opshin.builder.from_plutus_schema",
"url":19,
"doc":"Convert from a dictionary representing a json schema according to CIP 57 Plutus Blueprint",
"func":1
},
{
"ref":"opshin.builder.apply_parameters",
"url":19,
"doc":"Expects a plutus script (compiled) and returns the compiled script from applying parameters to it",
"func":1
},
{
"ref":"opshin.builder.load",
"url":19,
"doc":"Load a contract from a file or directory and generate the artifacts",
"func":1
},
{
"ref":"opshin.ledger",
"url":20,
"doc":"OpShin provides some helper classes that define concepts introduced in PlutusTx and used by the cardano node to encode data. In particular you find the definition of the entire Script Context for Plutus V2 in the file  api_v2 .   from opshin.ledger.api_v2 import   "
},
{
"ref":"opshin.ledger.api_v2",
"url":21,
"doc":"The PlutusV2 ledger API. All classes involved in defining the ScriptContext passed by the node."
},
{
"ref":"opshin.ledger.api_v2.TxId",
"url":21,
"doc":"A transaction id, a 64 bytes long hash of the transaction body (also called transaction hash). Example value: TxId(bytes.fromhex(\"842a4d37b036da6ab3c04331240e67d81746beb44f23ad79703e026705361956\" "
},
{
"ref":"opshin.ledger.api_v2.TxId.tx_id",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxId.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TrueData",
"url":21,
"doc":"A Datum that represents True in Haskell implementations. It is thus used as an encoding for True in the ScriptContext. Example value: TrueData()"
},
{
"ref":"opshin.ledger.api_v2.TrueData.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.FalseData",
"url":21,
"doc":"A Datum that represents False in Haskell implementations. It is thus used as an encoding for False in the ScriptContext. Example value: FalseData()"
},
{
"ref":"opshin.ledger.api_v2.FalseData.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxOutRef",
"url":21,
"doc":"A reference to a transaction output (hash/id + index)"
},
{
"ref":"opshin.ledger.api_v2.TxOutRef.id",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxOutRef.idx",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxOutRef.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.PubKeyCredential",
"url":21,
"doc":"Part of an address that is authenticated by a public key hash Example value: PubKeyCredential(bytes.fromhex(\"c06ddaad12fc4ded18e56feac72957c1aa75fce6096b40e63ec88274\" "
},
{
"ref":"opshin.ledger.api_v2.PubKeyCredential.credential_hash",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.PubKeyCredential.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.ScriptCredential",
"url":21,
"doc":"Part of an address that is authenticated by a smart cotnract Example value: ScriptCredential(bytes.fromhex(\"c06ddaad12fc4ded18e56feac72957c1aa75fce6096b40e63ec88274\" "
},
{
"ref":"opshin.ledger.api_v2.ScriptCredential.credential_hash",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.ScriptCredential.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.StakingHash",
"url":21,
"doc":"Indicates that the stake of this address is controlled by the associated credential"
},
{
"ref":"opshin.ledger.api_v2.StakingHash.value",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.StakingHash.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.StakingPtr",
"url":21,
"doc":"Indicates that the stake of this address is controlled by the associated pointer. In an address, a chain pointer refers to a point of the chain containing a stake key registration certificate. A point is identified by the 3 coordinates in this object."
},
{
"ref":"opshin.ledger.api_v2.StakingPtr.slot_no",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.StakingPtr.tx_index",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.StakingPtr.cert_index",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.StakingPtr.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.NoStakingCredential",
"url":21,
"doc":"Indicates that this address has no staking credentials. Its funds can not be delegated."
},
{
"ref":"opshin.ledger.api_v2.NoStakingCredential.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeStakingCredential",
"url":21,
"doc":"Indicates that this address has staking credentials. Its funds can be delegated by the credentialed user."
},
{
"ref":"opshin.ledger.api_v2.SomeStakingCredential.staking_credential",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeStakingCredential.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Address",
"url":21,
"doc":"A Shelley address, consisting of a payment and staking credential"
},
{
"ref":"opshin.ledger.api_v2.Address.payment_credential",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Address.staking_credential",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Address.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeDatumHash",
"url":21,
"doc":"Indicates that there is a datum associated with this output, which has the given hash."
},
{
"ref":"opshin.ledger.api_v2.SomeDatumHash.datum_hash",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeDatumHash.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeScriptHash",
"url":21,
"doc":"Indicates that there is a script associated with this output, which has the given hash."
},
{
"ref":"opshin.ledger.api_v2.SomeScriptHash.script_hash",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeScriptHash.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.NoOutputDatum",
"url":21,
"doc":"Indicates that there is no datum associated with an output"
},
{
"ref":"opshin.ledger.api_v2.NoOutputDatum.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeOutputDatumHash",
"url":21,
"doc":"Indicates that there is an datum associated with an output, which has the attached hash"
},
{
"ref":"opshin.ledger.api_v2.SomeOutputDatumHash.datum_hash",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeOutputDatumHash.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeOutputDatum",
"url":21,
"doc":"Indicates that there is an datum associated with an output, which is inlined and equal to the attached datum"
},
{
"ref":"opshin.ledger.api_v2.SomeOutputDatum.datum",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.SomeOutputDatum.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.NoScriptHash",
"url":21,
"doc":"Indicates that there is no script associated with an output"
},
{
"ref":"opshin.ledger.api_v2.NoScriptHash.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxOut",
"url":21,
"doc":"The plutus representation of an transaction output, consisting of - address: address owning this output - value: tokens associated with this output - datum: datum associated with this output - reference_script: reference script associated with this output"
},
{
"ref":"opshin.ledger.api_v2.TxOut.address",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxOut.value",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxOut.datum",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxOut.reference_script",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxOut.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInInfo",
"url":21,
"doc":"The plutus representation of an transaction output, that is consumed by the transaction."
},
{
"ref":"opshin.ledger.api_v2.TxInInfo.out_ref",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInInfo.resolved",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInInfo.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertDelegRegKey",
"url":21,
"doc":"DCertDelegRegKey(value: Union[opshin.ledger.api_v2.StakingHash, opshin.ledger.api_v2.StakingPtr])"
},
{
"ref":"opshin.ledger.api_v2.DCertDelegRegKey.value",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertDelegRegKey.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertDelegDeRegKey",
"url":21,
"doc":"DCertDelegDeRegKey(value: Union[opshin.ledger.api_v2.StakingHash, opshin.ledger.api_v2.StakingPtr])"
},
{
"ref":"opshin.ledger.api_v2.DCertDelegDeRegKey.value",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertDelegDeRegKey.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertDelegDelegate",
"url":21,
"doc":"DCertDelegDelegate(delegator: Union[opshin.ledger.api_v2.StakingHash, opshin.ledger.api_v2.StakingPtr], delegatee: bytes)"
},
{
"ref":"opshin.ledger.api_v2.DCertDelegDelegate.delegator",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertDelegDelegate.delegatee",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertDelegDelegate.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertPoolRegister",
"url":21,
"doc":"DCertPoolRegister(pool_id: bytes, pool_vfr: bytes)"
},
{
"ref":"opshin.ledger.api_v2.DCertPoolRegister.pool_id",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertPoolRegister.pool_vfr",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertPoolRegister.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertPoolRetire",
"url":21,
"doc":"DCertPoolRetire(retirement_certificate: bytes, epoch: int)"
},
{
"ref":"opshin.ledger.api_v2.DCertPoolRetire.retirement_certificate",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertPoolRetire.epoch",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertPoolRetire.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertGenesis",
"url":21,
"doc":"DCertGenesis()"
},
{
"ref":"opshin.ledger.api_v2.DCertGenesis.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.DCertMir",
"url":21,
"doc":"DCertMir()"
},
{
"ref":"opshin.ledger.api_v2.DCertMir.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.NegInfPOSIXTime",
"url":21,
"doc":"Negative infinite POSIX time, used to indicate that there is no lower bound for the execution of this transaction"
},
{
"ref":"opshin.ledger.api_v2.NegInfPOSIXTime.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.FinitePOSIXTime",
"url":21,
"doc":"Finite POSIX time, used to indicate that there is a lower or upper bound for the execution of this transaction"
},
{
"ref":"opshin.ledger.api_v2.FinitePOSIXTime.time",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.FinitePOSIXTime.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.PosInfPOSIXTime",
"url":21,
"doc":"Infinite POSIX time, used to indicate that there is no upper bound for the execution of this transaction"
},
{
"ref":"opshin.ledger.api_v2.PosInfPOSIXTime.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.UpperBoundPOSIXTime",
"url":21,
"doc":"Upper bound for the execution of this transaction"
},
{
"ref":"opshin.ledger.api_v2.UpperBoundPOSIXTime.limit",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.UpperBoundPOSIXTime.closed",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.UpperBoundPOSIXTime.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.LowerBoundPOSIXTime",
"url":21,
"doc":"Lower bound for the execution of this transaction"
},
{
"ref":"opshin.ledger.api_v2.LowerBoundPOSIXTime.limit",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.LowerBoundPOSIXTime.closed",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.LowerBoundPOSIXTime.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.POSIXTimeRange",
"url":21,
"doc":"Time range in which this transaction can be executed"
},
{
"ref":"opshin.ledger.api_v2.POSIXTimeRange.lower_bound",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.POSIXTimeRange.upper_bound",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.POSIXTimeRange.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Minting",
"url":21,
"doc":"Script purpose indicating that the given policy id is being minted or burned"
},
{
"ref":"opshin.ledger.api_v2.Minting.policy_id",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Minting.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Spending",
"url":21,
"doc":"Script purpose indicating that the given transaction output is being spent, which is owned by the invoked contract"
},
{
"ref":"opshin.ledger.api_v2.Spending.tx_out_ref",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Spending.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Rewarding",
"url":21,
"doc":"Rewarding(staking_credential: Union[opshin.ledger.api_v2.StakingHash, opshin.ledger.api_v2.StakingPtr])"
},
{
"ref":"opshin.ledger.api_v2.Rewarding.staking_credential",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Rewarding.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Certifying",
"url":21,
"doc":"Certifying(d_cert: Union[opshin.ledger.api_v2.DCertDelegRegKey, opshin.ledger.api_v2.DCertDelegDeRegKey, opshin.ledger.api_v2.DCertDelegDelegate, opshin.ledger.api_v2.DCertPoolRegister, opshin.ledger.api_v2.DCertPoolRetire, opshin.ledger.api_v2.DCertGenesis, opshin.ledger.api_v2.DCertMir])"
},
{
"ref":"opshin.ledger.api_v2.Certifying.d_cert",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.Certifying.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo",
"url":21,
"doc":"A complex agglomeration of everything that could be of interest to the executed script, regarding the transaction that invoked the script"
},
{
"ref":"opshin.ledger.api_v2.TxInfo.inputs",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.reference_inputs",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.outputs",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.fee",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.mint",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.dcert",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.wdrl",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.valid_range",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.signatories",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.redeemers",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.data",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.id",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.TxInfo.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.ScriptContext",
"url":21,
"doc":"Auxiliary information about the transaction and reason for invocation of the called script."
},
{
"ref":"opshin.ledger.api_v2.ScriptContext.tx_info",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.ScriptContext.purpose",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.api_v2.ScriptContext.CONSTR_ID",
"url":21,
"doc":""
},
{
"ref":"opshin.ledger.interval",
"url":22,
"doc":"A library to assist with interval handling"
},
{
"ref":"opshin.ledger.interval.compare",
"url":22,
"doc":"",
"func":1
},
{
"ref":"opshin.ledger.interval.compare_extended_helper",
"url":22,
"doc":"",
"func":1
},
{
"ref":"opshin.ledger.interval.compare_extended",
"url":22,
"doc":"",
"func":1
},
{
"ref":"opshin.ledger.interval.get_bool",
"url":22,
"doc":"",
"func":1
},
{
"ref":"opshin.ledger.interval.compare_upper_bound",
"url":22,
"doc":"",
"func":1
},
{
"ref":"opshin.ledger.interval.compare_lower_bound",
"url":22,
"doc":"",
"func":1
},
{
"ref":"opshin.ledger.interval.contains",
"url":22,
"doc":"Returns True if the interval  b is entirely contained in  a .",
"func":1
},
{
"ref":"opshin.ledger.interval.make_range",
"url":22,
"doc":"Create a bounded interval from the given time  lower_bound up to the given  upper_bound , including the given time",
"func":1
},
{
"ref":"opshin.ledger.interval.make_from",
"url":22,
"doc":"Create a bounded interval from the given time  lower_bound up to infinity, including the given time",
"func":1
},
{
"ref":"opshin.ledger.interval.make_to",
"url":22,
"doc":"Create a bounded interval from negative infinity up to the given  upper_bound , including the given time",
"func":1
},
{
"ref":"opshin.types",
"url":23,
"doc":""
},
{
"ref":"opshin.types.FunctionType",
"url":23,
"doc":"FunctionType(argtyps: List[opshin.types.Type], rettyp: opshin.types.Type, bound_vars: List[str] =  )"
},
{
"ref":"opshin.types.FunctionType.argtyps",
"url":23,
"doc":""
},
{
"ref":"opshin.types.FunctionType.rettyp",
"url":23,
"doc":""
},
{
"ref":"opshin.types.FunctionType.bound_vars",
"url":23,
"doc":""
},
{
"ref":"opshin.types.FunctionType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.FunctionType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.FunctionType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.FunctionType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.FunctionType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.FunctionType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.FunctionType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.FunctionType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.FunctionType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.TypeInferenceError",
"url":23,
"doc":"Assertion failed."
},
{
"ref":"opshin.types.Type",
"url":23,
"doc":""
},
{
"ref":"opshin.types.Type.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.Type.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.Type.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.Type.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.Type.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.Type.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.Type.copy_only_attributes",
"url":23,
"doc":"Pluthon function that returns a copy of only the attributes of the object",
"func":1
},
{
"ref":"opshin.types.Type.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.Type.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.Record",
"url":23,
"doc":"Record(name: str, orig_name: str, constructor: int, fields: Union[List[Tuple[str, opshin.types.Type , frozenlist2.frozenlist])"
},
{
"ref":"opshin.types.Record.name",
"url":23,
"doc":""
},
{
"ref":"opshin.types.Record.orig_name",
"url":23,
"doc":""
},
{
"ref":"opshin.types.Record.constructor",
"url":23,
"doc":""
},
{
"ref":"opshin.types.Record.fields",
"url":23,
"doc":""
},
{
"ref":"opshin.types.ClassType",
"url":23,
"doc":"ClassType()"
},
{
"ref":"opshin.types.ClassType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.ClassType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.ClassType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.ClassType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.ClassType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.ClassType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.ClassType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.ClassType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.ClassType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.AnyType",
"url":23,
"doc":"The top element in the partial order on types (excluding FunctionTypes, which do not compare to anything)"
},
{
"ref":"opshin.types.AnyType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.AnyType.attribute",
"url":23,
"doc":"The attributes of this class. Need to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.AnyType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.AnyType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.AnyType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.AnyType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.AnyType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.AnyType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.AnyType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.AtomicType",
"url":23,
"doc":"AtomicType()"
},
{
"ref":"opshin.types.AtomicType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.AtomicType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.AtomicType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.AtomicType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.AtomicType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.AtomicType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.AtomicType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.AtomicType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.AtomicType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.RecordType",
"url":23,
"doc":"RecordType(record: opshin.types.Record)"
},
{
"ref":"opshin.types.RecordType.record",
"url":23,
"doc":""
},
{
"ref":"opshin.types.RecordType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.RecordType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.RecordType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.RecordType.attribute",
"url":23,
"doc":"The attributes of this class. Need to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.RecordType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.RecordType.stringify",
"url":23,
"doc":"Returns a stringified version of the object",
"func":1
},
{
"ref":"opshin.types.RecordType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.RecordType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.RecordType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.UnionType",
"url":23,
"doc":"UnionType(typs: List[opshin.types.RecordType])"
},
{
"ref":"opshin.types.UnionType.typs",
"url":23,
"doc":""
},
{
"ref":"opshin.types.UnionType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.UnionType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.UnionType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.UnionType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.UnionType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.UnionType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.UnionType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.UnionType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.UnionType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.TupleType",
"url":23,
"doc":"TupleType(typs: List[opshin.types.Type])"
},
{
"ref":"opshin.types.TupleType.typs",
"url":23,
"doc":""
},
{
"ref":"opshin.types.TupleType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.TupleType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.TupleType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.TupleType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.TupleType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.TupleType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.TupleType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.TupleType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.TupleType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.PairType",
"url":23,
"doc":"An internal type representing built-in PlutusData pairs"
},
{
"ref":"opshin.types.PairType.l_typ",
"url":23,
"doc":""
},
{
"ref":"opshin.types.PairType.r_typ",
"url":23,
"doc":""
},
{
"ref":"opshin.types.PairType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.PairType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.PairType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.PairType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.PairType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.PairType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.PairType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.PairType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.PairType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.ListType",
"url":23,
"doc":"ListType(typ: opshin.types.Type)"
},
{
"ref":"opshin.types.ListType.typ",
"url":23,
"doc":""
},
{
"ref":"opshin.types.ListType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.ListType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.ListType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.ListType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.ListType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.ListType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.ListType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.ListType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.ListType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.DictType",
"url":23,
"doc":"DictType(key_typ: opshin.types.Type, value_typ: opshin.types.Type)"
},
{
"ref":"opshin.types.DictType.key_typ",
"url":23,
"doc":""
},
{
"ref":"opshin.types.DictType.value_typ",
"url":23,
"doc":""
},
{
"ref":"opshin.types.DictType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.DictType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.DictType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.DictType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.DictType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.DictType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.DictType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.DictType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.DictType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.InstanceType",
"url":23,
"doc":"InstanceType(typ: opshin.types.ClassType)"
},
{
"ref":"opshin.types.InstanceType.typ",
"url":23,
"doc":""
},
{
"ref":"opshin.types.InstanceType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.InstanceType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.InstanceType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.InstanceType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.InstanceType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.InstanceType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.InstanceType.copy_only_attributes",
"url":23,
"doc":"Pluthon function that returns a copy of only the attributes of the object",
"func":1
},
{
"ref":"opshin.types.InstanceType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.InstanceType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.IntegerType",
"url":23,
"doc":"IntegerType()"
},
{
"ref":"opshin.types.IntegerType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.IntegerType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.IntegerType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.IntegerType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.IntegerType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.IntegerType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.IntegerType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.IntegerType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.IntegerType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.StringType",
"url":23,
"doc":"StringType()"
},
{
"ref":"opshin.types.StringType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.StringType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.StringType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.StringType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.StringType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.StringType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.StringType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.StringType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.StringType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.ByteStringType",
"url":23,
"doc":"ByteStringType()"
},
{
"ref":"opshin.types.ByteStringType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.ByteStringType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.ByteStringType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.ByteStringType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.ByteStringType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.ByteStringType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.ByteStringType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.ByteStringType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.ByteStringType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.BoolType",
"url":23,
"doc":"BoolType()"
},
{
"ref":"opshin.types.BoolType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.BoolType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.BoolType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.BoolType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.BoolType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.BoolType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.BoolType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.BoolType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.BoolType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.UnitType",
"url":23,
"doc":"UnitType()"
},
{
"ref":"opshin.types.UnitType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.UnitType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.UnitType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.UnitType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.UnitType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.UnitType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.UnitType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.UnitType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.UnitType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.InaccessibleType",
"url":23,
"doc":"A type that blocks overwriting of a function"
},
{
"ref":"opshin.types.InaccessibleType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.InaccessibleType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.InaccessibleType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.InaccessibleType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.InaccessibleType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.InaccessibleType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.InaccessibleType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.InaccessibleType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.InaccessibleType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.repeated_addition",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.PowImpl",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.ByteStrIntMulImpl",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.StrIntMulImpl",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunction",
"url":23,
"doc":""
},
{
"ref":"opshin.types.PolymorphicFunction.type_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunction.impl_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.StrImpl",
"url":23,
"doc":""
},
{
"ref":"opshin.types.StrImpl.type_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.StrImpl.impl_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.IntImpl",
"url":23,
"doc":""
},
{
"ref":"opshin.types.IntImpl.type_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.IntImpl.impl_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.BoolImpl",
"url":23,
"doc":""
},
{
"ref":"opshin.types.BoolImpl.type_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.BoolImpl.impl_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.BytesImpl",
"url":23,
"doc":""
},
{
"ref":"opshin.types.BytesImpl.type_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.BytesImpl.impl_from_args",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType",
"url":23,
"doc":"A special type of builtin that may act differently on different parameters"
},
{
"ref":"opshin.types.PolymorphicFunctionType.polymorphic_function",
"url":23,
"doc":""
},
{
"ref":"opshin.types.PolymorphicFunctionType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType",
"url":23,
"doc":"PolymorphicFunctionInstanceType(typ: opshin.types.FunctionType, polymorphic_function: opshin.types.PolymorphicFunction)"
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.typ",
"url":23,
"doc":""
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.polymorphic_function",
"url":23,
"doc":""
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.attribute_type",
"url":23,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.attribute",
"url":23,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.copy_only_attributes",
"url":23,
"doc":"Pluthon function that returns a copy of only the attributes of the object",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.types.PolymorphicFunctionInstanceType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.types.empty_list",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.transform_ext_params_map",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.types.transform_output_map",
"url":23,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize",
"url":24,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_pass",
"url":25,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_pass.OptimizeRemovePass",
"url":25,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.optimize.optimize_remove_pass.OptimizeRemovePass.step",
"url":25,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_pass.OptimizeRemovePass.visit_Pass",
"url":25,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_pass.OptimizeRemovePass.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_comments",
"url":27,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants",
"url":27,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants.step",
"url":27,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants.visit_Expr",
"url":27,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars",
"url":28,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.NameLoadCollector",
"url":28,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.NameLoadCollector.step",
"url":28,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.NameLoadCollector.visit_Name",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.NameLoadCollector.visit_ClassDef",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.NameLoadCollector.visit_FunctionDef",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.NameLoadCollector.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor",
"url":28,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor.step",
"url":28,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor.generic_visit",
"url":28,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Lambda",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Constant",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_RawPlutoExpr",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Name",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars",
"url":28,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.step",
"url":28,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.loaded_vars",
"url":28,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed_avail_names",
"url":28,
"doc":""
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.enter_scope",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.exit_scope",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.set_guaranteed",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Module",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_If",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_While",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_For",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Assign",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_AnnAssign",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_ClassDef",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_FunctionDef",
"url":28,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding",
"url":29,
"doc":""
},
{
"ref":"opshin.optimize.optimize_const_folding.ShallowNameDefCollector",
"url":29,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.optimize.optimize_const_folding.ShallowNameDefCollector.step",
"url":29,
"doc":""
},
{
"ref":"opshin.optimize.optimize_const_folding.ShallowNameDefCollector.visit_Name",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.ShallowNameDefCollector.visit_ClassDef",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.ShallowNameDefCollector.visit_FunctionDef",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.ShallowNameDefCollector.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor",
"url":29,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.step",
"url":29,
"doc":""
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit_For",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit_While",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit_If",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit_Name",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit_ClassDef",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit_FunctionDef",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit_Import",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit_ImportFrom",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.DefinedTimesVisitor.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding",
"url":29,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.step",
"url":29,
"doc":""
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.enter_scope",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.add_var_visible",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.add_vars_visible",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.add_constant",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visible_vars",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.exit_scope",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.update_constants",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visit_Module",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visit_FunctionDef",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visit_ClassDef",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visit_ImportFrom",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visit_Import",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visit_Assign",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visit_AnnAssign",
"url":29,
"doc":"",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.generic_visit",
"url":29,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"opshin.optimize.optimize_const_folding.OptimizeConstantFolding.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.compiler",
"url":30,
"doc":""
},
{
"ref":"opshin.compiler.rec_constant_map_data",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.rec_constant_map",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.wrap_validator_double_function",
"url":30,
"doc":"Wraps the validator function to enable a double function as minting script pass_through defines how many parameters x would normally take and should be passed through to x",
"func":1
},
{
"ref":"opshin.compiler.FunctionBoundVarsCollector",
"url":30,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.compiler.FunctionBoundVarsCollector.visit_FunctionDef",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.extract_function_bound_vars",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler",
"url":30,
"doc":"Expects a TypedAST and returns UPLC/Pluto like code"
},
{
"ref":"opshin.compiler.PlutoCompiler.step",
"url":30,
"doc":""
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_sequence",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_BinOp",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_BoolOp",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_UnaryOp",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Compare",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Module",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Constant",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_NoneType",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Assign",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_AnnAssign",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Name",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Expr",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Call",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_FunctionDef",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_While",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_For",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_If",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Return",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Pass",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Subscript",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Tuple",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_ClassDef",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Attribute",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Assert",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_RawPlutoExpr",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_List",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_Dict",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_IfExp",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_ListComp",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_FormattedValue",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit_JoinedStr",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.generic_visit",
"url":30,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"opshin.compiler.PlutoCompiler.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.compiler.compile",
"url":30,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite",
"url":31,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_cast_condition",
"url":32,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions",
"url":32,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions.step",
"url":32,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions.visit_Module",
"url":32,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions.visit_If",
"url":32,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions.visit_IfExp",
"url":32,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions.visit_While",
"url":32,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions.visit_BoolOp",
"url":32,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions.visit_Assert",
"url":32,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_cast_condition.RewriteConditions.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_remove_type_stuff",
"url":33,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff",
"url":33,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff.step",
"url":33,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff.visit_Assign",
"url":33,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_typing",
"url":34,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_typing.RewriteImportTyping",
"url":34,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_import_typing.RewriteImportTyping.step",
"url":34,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_typing.RewriteImportTyping.imports_typing",
"url":34,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_typing.RewriteImportTyping.visit_ImportFrom",
"url":34,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_typing.RewriteImportTyping.visit_ClassDef",
"url":34,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_typing.RewriteImportTyping.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_inject_builtin_constr",
"url":35,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr",
"url":35,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr.step",
"url":35,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr.visit_Module",
"url":35,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_dataclasses",
"url":36,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses",
"url":36,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.step",
"url":36,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.imports_dataclasses",
"url":36,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.visit_ImportFrom",
"url":36,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.visit_ClassDef",
"url":36,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_subscript38",
"url":37,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_subscript38.RewriteSubscript38",
"url":37,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_subscript38.RewriteSubscript38.step",
"url":37,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_subscript38.RewriteSubscript38.visit_Index",
"url":37,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_subscript38.RewriteSubscript38.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping",
"url":38,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_scoping.ShallowNameDefCollector",
"url":38,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.rewrite.rewrite_scoping.ShallowNameDefCollector.step",
"url":38,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_scoping.ShallowNameDefCollector.visit_Name",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.ShallowNameDefCollector.visit_ClassDef",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.ShallowNameDefCollector.visit_FunctionDef",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.ShallowNameDefCollector.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping",
"url":38,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.latest_scope_id",
"url":38,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.scopes",
"url":38,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.step",
"url":38,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.variable_scope_id",
"url":38,
"doc":"find the id of the scope in which this variable is defined (closest to its usage)",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.enter_scope",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.exit_scope",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.set_variable_scope",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.map_name",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.visit_Module",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.visit_Name",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.visit_ClassDef",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.visit_FunctionDef",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.visit_NoneType",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RewriteScoping.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RecordScoper",
"url":38,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_scoping.RecordScoper.scope",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RecordScoper.visit_ClassDef",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_scoping.RecordScoper.visit_AnnAssign",
"url":38,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_augassign",
"url":39,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_augassign.RewriteAugAssign",
"url":39,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_augassign.RewriteAugAssign.step",
"url":39,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_augassign.RewriteAugAssign.visit_AugAssign",
"url":39,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_augassign.RewriteAugAssign.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_integrity_check",
"url":40,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_integrity_check.IntegrityCheckImpl",
"url":40,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_integrity_check.IntegrityCheckImpl.type_from_args",
"url":40,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_integrity_check.IntegrityCheckImpl.impl_from_args",
"url":40,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_integrity_check.RewriteImportIntegrityCheck",
"url":40,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_import_integrity_check.RewriteImportIntegrityCheck.step",
"url":40,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_integrity_check.RewriteImportIntegrityCheck.visit_ImportFrom",
"url":40,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_integrity_check.RewriteImportIntegrityCheck.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_forbidden_overwrites",
"url":41,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_forbidden_overwrites.ForbiddenOverwriteError",
"url":41,
"doc":"Inappropriate argument value (of correct type)."
},
{
"ref":"opshin.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites",
"url":41,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites.step",
"url":41,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites.visit_Name",
"url":41,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_inject_builtins",
"url":42,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins",
"url":42,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins.step",
"url":42,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins.visit_Module",
"url":42,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_plutusdata",
"url":43,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData",
"url":43,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.step",
"url":43,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.imports_plutus_data",
"url":43,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.visit_ImportFrom",
"url":43,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.visit_ClassDef",
"url":43,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_uplc_builtins",
"url":44,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_uplc_builtins.RewriteImportUPLCBuiltins",
"url":44,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_import_uplc_builtins.RewriteImportUPLCBuiltins.step",
"url":44,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_uplc_builtins.RewriteImportUPLCBuiltins.imports_uplc_builtins",
"url":44,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_uplc_builtins.RewriteImportUPLCBuiltins.visit_ImportFrom",
"url":44,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_uplc_builtins.RewriteImportUPLCBuiltins.visit_FunctionDef",
"url":44,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_uplc_builtins.RewriteImportUPLCBuiltins.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib",
"url":45,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType",
"url":45,
"doc":"A pseudo class that is the result of python hash functions that need a 'digest' call"
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.attribute_type",
"url":45,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.attribute",
"url":45,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.copy_only_attributes",
"url":23,
"doc":"Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too). For anything but record types and union types, this is the identity function.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.constr_type",
"url":23,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.constr",
"url":23,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.cmp",
"url":23,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.stringify",
"url":23,
"doc":"Returns a stringified version of the object The recursive parameter informs the method whether it was invoked recursively from another invokation",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.binop_type",
"url":23,
"doc":"Type of a binary operation between self and other.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.HashType.binop",
"url":23,
"doc":"Implements a binary operation between self and other",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.PythonHashlib",
"url":45,
"doc":"An enumeration."
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.PythonHashlib.sha256",
"url":45,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.PythonHashlib.sha3_256",
"url":45,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.PythonHashlib.blake2b",
"url":45,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.RewriteImportHashlib",
"url":45,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.RewriteImportHashlib.step",
"url":45,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.RewriteImportHashlib.imports_hashlib",
"url":45,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.RewriteImportHashlib.visit_ImportFrom",
"url":45,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import_hashlib.RewriteImportHashlib.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_tuple_assign",
"url":46,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_tuple_assign.RewriteTupleAssign",
"url":46,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_tuple_assign.RewriteTupleAssign.step",
"url":46,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_tuple_assign.RewriteTupleAssign.unique_id",
"url":46,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_tuple_assign.RewriteTupleAssign.visit_Assign",
"url":46,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_tuple_assign.RewriteTupleAssign.visit_For",
"url":46,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_tuple_assign.RewriteTupleAssign.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_comparison_chaining",
"url":47,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_comparison_chaining.RewriteComparisonChaining",
"url":47,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_comparison_chaining.RewriteComparisonChaining.step",
"url":47,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_comparison_chaining.RewriteComparisonChaining.visit_Compare",
"url":47,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_comparison_chaining.RewriteComparisonChaining.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_forbidden_return",
"url":48,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_forbidden_return.RewriteForbiddenReturn",
"url":48,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_forbidden_return.RewriteForbiddenReturn.step",
"url":48,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_forbidden_return.RewriteForbiddenReturn.visit_Return",
"url":48,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_forbidden_return.RewriteForbiddenReturn.visit_FunctionDef",
"url":48,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_forbidden_return.RewriteForbiddenReturn.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import",
"url":49,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import.import_module",
"url":49,
"doc":"An approximate implementation of import.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import.RewriteLocation",
"url":49,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_import.RewriteLocation.visit",
"url":49,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import.RewriteImport",
"url":49,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_import.RewriteImport.step",
"url":49,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_import.RewriteImport.visit_ImportFrom",
"url":49,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_import.RewriteImport.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_orig_name",
"url":50,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_orig_name.RewriteOrigName",
"url":50,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.rewrite.rewrite_orig_name.RewriteOrigName.step",
"url":50,
"doc":""
},
{
"ref":"opshin.rewrite.rewrite_orig_name.RewriteOrigName.visit_Name",
"url":50,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_orig_name.RewriteOrigName.visit_ClassDef",
"url":50,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_orig_name.RewriteOrigName.visit_NoneType",
"url":50,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_orig_name.RewriteOrigName.visit_FunctionDef",
"url":50,
"doc":"",
"func":1
},
{
"ref":"opshin.rewrite.rewrite_orig_name.RewriteOrigName.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.std",
"url":51,
"doc":"OpShin provides a few features in its standard libary. You can import modules from there (i.e. the  fractions module) with   from opshin.std.fractions import   "
},
{
"ref":"opshin.std.integrity",
"url":52,
"doc":"A special libary that gives access to a function that checks the integrity of PlutusDatum objects."
},
{
"ref":"opshin.std.integrity.check_integrity",
"url":52,
"doc":"Checks the integrity of a PlutusDatum object. In particular, it takes an object of any type and checks that - the constructor id matches the id defined in the type - the fields specified in the type are present - no additional fields are present This has no equivalent in Python.",
"func":1
},
{
"ref":"opshin.std.builtins",
"url":53,
"doc":"A special libary that gives direct access to UPLC built-ins It is valid code and parts of it may be copied if not all built-ins are required by the user."
},
{
"ref":"opshin.std.builtins.add_integer",
"url":53,
"doc":"Adds two integers and returns the result.",
"func":1
},
{
"ref":"opshin.std.builtins.subtract_integer",
"url":53,
"doc":"Subtract fist integer by second and return the result.",
"func":1
},
{
"ref":"opshin.std.builtins.multiply_integer",
"url":53,
"doc":"Multiply 2 integers and return the result.",
"func":1
},
{
"ref":"opshin.std.builtins.divide_integer",
"url":53,
"doc":"Divide first integer by second and return the result.",
"func":1
},
{
"ref":"opshin.std.builtins.quotient_integer",
"url":53,
"doc":"Quotient of first integer by second and return the result.",
"func":1
},
{
"ref":"opshin.std.builtins.remainder_integer",
"url":53,
"doc":"Remainder of first integer by second and return the result.",
"func":1
},
{
"ref":"opshin.std.builtins.mod_integer",
"url":53,
"doc":"Modulus of first integer by second and return the result.",
"func":1
},
{
"ref":"opshin.std.builtins.equals_integer",
"url":53,
"doc":"Equality between two integers.",
"func":1
},
{
"ref":"opshin.std.builtins.less_than_integer",
"url":53,
"doc":"Returns x < y",
"func":1
},
{
"ref":"opshin.std.builtins.less_than_equals_integer",
"url":53,
"doc":"Returns x <= y.",
"func":1
},
{
"ref":"opshin.std.builtins.append_byte_string",
"url":53,
"doc":"Concatenate two bytestrings.",
"func":1
},
{
"ref":"opshin.std.builtins.cons_byte_string",
"url":53,
"doc":"Prepend a byte, represented by a natural number (Integer), to a bytestring.",
"func":1
},
{
"ref":"opshin.std.builtins.slice_byte_string",
"url":53,
"doc":"Slice a bytestring using given indices (inclusive on both ends). The resulting bytestring is z[x:x+y].",
"func":1
},
{
"ref":"opshin.std.builtins.length_of_byte_string",
"url":53,
"doc":"Get the length of a bytestring.",
"func":1
},
{
"ref":"opshin.std.builtins.index_byte_string",
"url":53,
"doc":"Get the byte at given index from a bytestring.",
"func":1
},
{
"ref":"opshin.std.builtins.equals_byte_string",
"url":53,
"doc":"Returns x  y.",
"func":1
},
{
"ref":"opshin.std.builtins.less_than_byte_string",
"url":53,
"doc":"Returns x < y.",
"func":1
},
{
"ref":"opshin.std.builtins.less_than_equals_byte_string",
"url":53,
"doc":"Returns x <= y.",
"func":1
},
{
"ref":"opshin.std.builtins.sha2_256",
"url":53,
"doc":"Hash a bytestring using SHA-256.",
"func":1
},
{
"ref":"opshin.std.builtins.sha3_256",
"url":53,
"doc":"Hash a bytestring using SHA3-256.",
"func":1
},
{
"ref":"opshin.std.builtins.blake2b_256",
"url":53,
"doc":"Hash a bytestring using Blake2B-256.",
"func":1
},
{
"ref":"opshin.std.builtins.verify_ed25519_signature",
"url":53,
"doc":"Given PubKey, Message, and Signature, verify the Ed25519 signature.",
"func":1
},
{
"ref":"opshin.std.builtins.verify_ecdsa_secp256k1_signature",
"url":53,
"doc":"Given PubKey, Message, and Signature, verify the ECDSA signature.",
"func":1
},
{
"ref":"opshin.std.builtins.verify_schnorr_secp256k1_signature",
"url":53,
"doc":"Given PubKey, Message, and Signature, verify the Schnorr signature.",
"func":1
},
{
"ref":"opshin.std.builtins.append_string",
"url":53,
"doc":"Concatenate two strings/texts.",
"func":1
},
{
"ref":"opshin.std.builtins.equals_string",
"url":53,
"doc":"Returns x  y.",
"func":1
},
{
"ref":"opshin.std.builtins.encode_utf8",
"url":53,
"doc":"Encode a string/text using UTF-8.",
"func":1
},
{
"ref":"opshin.std.builtins.decode_utf8",
"url":53,
"doc":"Decode a string/text using UTF-8.",
"func":1
},
{
"ref":"opshin.std.builtins.constr_data",
"url":53,
"doc":"Create a datum with constructor id x and fields y.",
"func":1
},
{
"ref":"opshin.std.builtins.equals_data",
"url":53,
"doc":"Equality between two complex classes.",
"func":1
},
{
"ref":"opshin.std.builtins.serialise_data",
"url":53,
"doc":"Serialize a datum into its CBOR representation.",
"func":1
},
{
"ref":"opshin.std.bitmap",
"url":54,
"doc":"The BitMap library provides tools to interact with a highly efficient datastructure that stores boolean values with minimal overhead (1 bit per bool)"
},
{
"ref":"opshin.std.bitmap.init_bitmap",
"url":54,
"doc":"Creates an empty bitmap with size bits",
"func":1
},
{
"ref":"opshin.std.bitmap.test_bitmap",
"url":54,
"doc":"Tests if bit at position i has been set to 1",
"func":1
},
{
"ref":"opshin.std.bitmap.set_bitmap",
"url":54,
"doc":"Sets a bit in the bitmap to 1",
"func":1
},
{
"ref":"opshin.std.bitmap.reset_bitmap",
"url":54,
"doc":"Sets a bit in the bitmap to 0",
"func":1
},
{
"ref":"opshin.std.bitmap.flip_bitmap",
"url":54,
"doc":"Flips a bit in the bitmap",
"func":1
},
{
"ref":"opshin.std.bitmap.size_bitmap",
"url":54,
"doc":"Returns the size of the bitmap in bits",
"func":1
},
{
"ref":"opshin.std.bitmap.any_bitmap",
"url":54,
"doc":"Returns whether any bit was set to 1",
"func":1
},
{
"ref":"opshin.std.bitmap.all_bitmap",
"url":54,
"doc":"Returns whether all bits were set to 1",
"func":1
},
{
"ref":"opshin.std.bitmap.none_bitmap",
"url":54,
"doc":"Returns whether no bits were set to 1",
"func":1
},
{
"ref":"opshin.std.math",
"url":55,
"doc":"An implementation of some math operations in opshin"
},
{
"ref":"opshin.std.math.gcd",
"url":55,
"doc":"",
"func":1
},
{
"ref":"opshin.std.math.sign",
"url":55,
"doc":"",
"func":1
},
{
"ref":"opshin.std.math.unsigned_int_from_bytes_big",
"url":55,
"doc":"Converts a bytestring into the corresponding integer, big/network byteorder, unsigned",
"func":1
},
{
"ref":"opshin.std.math.ceil",
"url":55,
"doc":"Returns a divided by b rounded towards positive infinity",
"func":1
},
{
"ref":"opshin.std.math.floor",
"url":55,
"doc":"Returns a divided by b rounded towards negative infinity",
"func":1
},
{
"ref":"opshin.std.hashlib",
"url":56,
"doc":"A std library that imports all valid hash functions from the builtin python hashlib library: If you want to have all hash functions in scope, simply add  from opshin.std.hashlib import  to the top of you python file."
},
{
"ref":"opshin.std.fractions",
"url":57,
"doc":"An implementation of fractions in opshin This does not maintain smallest possible notation invariants for the sake of efficiency - the user has full control over when to normalize the fractions and should do so using norm_fraction"
},
{
"ref":"opshin.std.fractions.Fraction",
"url":57,
"doc":"Fraction(numerator: int, denominator: int)"
},
{
"ref":"opshin.std.fractions.Fraction.numerator",
"url":57,
"doc":""
},
{
"ref":"opshin.std.fractions.Fraction.denominator",
"url":57,
"doc":""
},
{
"ref":"opshin.std.fractions.Fraction.CONSTR_ID",
"url":57,
"doc":""
},
{
"ref":"opshin.std.fractions.add_fraction",
"url":57,
"doc":"returns a + b",
"func":1
},
{
"ref":"opshin.std.fractions.neg_fraction",
"url":57,
"doc":"returns -a",
"func":1
},
{
"ref":"opshin.std.fractions.sub_fraction",
"url":57,
"doc":"returns a - b",
"func":1
},
{
"ref":"opshin.std.fractions.mul_fraction",
"url":57,
"doc":"returns a  b",
"func":1
},
{
"ref":"opshin.std.fractions.div_fraction",
"url":57,
"doc":"returns a / b",
"func":1
},
{
"ref":"opshin.std.fractions.norm_fraction",
"url":57,
"doc":"Restores the invariant that num/denom are in the smallest possible denomination and denominator > 0",
"func":1
},
{
"ref":"opshin.std.fractions.ge_fraction",
"url":57,
"doc":"returns a >= b",
"func":1
},
{
"ref":"opshin.std.fractions.le_fraction",
"url":57,
"doc":"returns a <= b",
"func":1
},
{
"ref":"opshin.std.fractions.eq_fraction",
"url":57,
"doc":"returns a  b",
"func":1
},
{
"ref":"opshin.std.fractions.lt_fraction",
"url":57,
"doc":"returns a < b",
"func":1
},
{
"ref":"opshin.std.fractions.gt_fraction",
"url":57,
"doc":"returns a > b",
"func":1
},
{
"ref":"opshin.std.fractions.floor_fraction",
"url":57,
"doc":"",
"func":1
},
{
"ref":"opshin.std.fractions.ceil_fraction",
"url":57,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference",
"url":58,
"doc":"An aggressive type inference based on the work of Aycock [1]. It only allows a subset of legal python operations which allow us to infer the type of all involved variables statically. Using this we can resolve overloaded functions when translating Python into UPLC where there is no dynamic type checking. Additionally, this conveniently implements an additional layer of security into the Smart Contract by checking type correctness. [1]: https: legacy.python.org/workshops/2000-01/proceedings/papers/aycock/aycock.html"
},
{
"ref":"opshin.type_inference.record_from_plutusdata",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.constant_type",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.union_types",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.intersection_types",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.TypeCheckVisitor",
"url":58,
"doc":"Generates the types to which objects are cast due to a boolean expression It returns a tuple of dictionaries which are a name -> type mapping for variable names that are assured to have a specific type if this expression is True/False respectively"
},
{
"ref":"opshin.type_inference.TypeCheckVisitor.generic_visit",
"url":58,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"opshin.type_inference.TypeCheckVisitor.visit_Call",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.TypeCheckVisitor.visit_BoolOp",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.TypeCheckVisitor.visit_UnaryOp",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.TypeCheckVisitor.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.type_inference.merge_scope",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer",
"url":58,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.step",
"url":58,
"doc":""
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.scopes",
"url":58,
"doc":""
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.variable_type",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.enter_scope",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.exit_scope",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.set_variable_type",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.implement_typechecks",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.type_from_annotation",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_sequence",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_ClassDef",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Constant",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Tuple",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_List",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Dict",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Assign",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_AnnAssign",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_If",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_While",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_For",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Name",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Compare",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_arg",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_arguments",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_FunctionDef",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Module",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Expr",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_BinOp",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_BoolOp",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_UnaryOp",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Subscript",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Call",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Pass",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Return",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Attribute",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_Assert",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_RawPlutoExpr",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_IfExp",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_comprehension",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_ListComp",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_FormattedValue",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_JoinedStr",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit_ImportFrom",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.generic_visit",
"url":58,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"opshin.type_inference.AggressiveTypeInferencer.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.type_inference.RecordReader",
"url":58,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.type_inference.RecordReader.name",
"url":58,
"doc":""
},
{
"ref":"opshin.type_inference.RecordReader.orig_name",
"url":58,
"doc":""
},
{
"ref":"opshin.type_inference.RecordReader.constructor",
"url":58,
"doc":""
},
{
"ref":"opshin.type_inference.RecordReader.attributes",
"url":58,
"doc":""
},
{
"ref":"opshin.type_inference.RecordReader.extract",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.RecordReader.visit_AnnAssign",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.RecordReader.visit_ClassDef",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.RecordReader.visit_Pass",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.RecordReader.visit_Assign",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.RecordReader.visit_Expr",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.RecordReader.generic_visit",
"url":58,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"opshin.type_inference.typed_ast",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.map_to_orig_name",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.ReturnExtractor",
"url":58,
"doc":"Utility to check that all paths end in Return statements with the proper type Returns whether there is no remaining path"
},
{
"ref":"opshin.type_inference.ReturnExtractor.visit_sequence",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.ReturnExtractor.visit_If",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.ReturnExtractor.visit_For",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.ReturnExtractor.visit_While",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.ReturnExtractor.visit_Return",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.ReturnExtractor.check_fulfills",
"url":58,
"doc":"",
"func":1
},
{
"ref":"opshin.type_inference.ReturnExtractor.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.util",
"url":26,
"doc":""
},
{
"ref":"opshin.util.distinct",
"url":26,
"doc":"Returns true iff the list consists of distinct elements",
"func":1
},
{
"ref":"opshin.util.TypedNodeTransformer",
"url":26,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.util.TypedNodeTransformer.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.util.TypedNodeVisitor",
"url":26,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.util.TypedNodeVisitor.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.util.CompilerError",
"url":26,
"doc":"Common base class for all non-exit exceptions."
},
{
"ref":"opshin.util.CompilingNodeTransformer",
"url":26,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Constant(value=node.id), ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"opshin.util.CompilingNodeTransformer.step",
"url":26,
"doc":""
},
{
"ref":"opshin.util.CompilingNodeTransformer.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.util.NoOp",
"url":26,
"doc":"A variation of the Compiling Node transformer that performs no changes"
},
{
"ref":"opshin.util.NoOp.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.util.CompilingNodeVisitor",
"url":26,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.util.CompilingNodeVisitor.step",
"url":26,
"doc":""
},
{
"ref":"opshin.util.CompilingNodeVisitor.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.util.data_from_json",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.datum_to_cbor",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.datum_to_json",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.custom_fix_missing_locations",
"url":26,
"doc":"Works like ast.fix_missing_location but forces it onto everything",
"func":1
},
{
"ref":"opshin.util.make_pattern",
"url":26,
"doc":"Creates a shared pattern from the given lambda, cached so that it is re-used in subsequent calls",
"func":1
},
{
"ref":"opshin.util.patternize",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.force_params",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.NameWriteCollector",
"url":26,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.util.NameWriteCollector.step",
"url":26,
"doc":""
},
{
"ref":"opshin.util.NameWriteCollector.visit_Name",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.NameWriteCollector.visit_ClassDef",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.NameWriteCollector.visit_FunctionDef",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.NameWriteCollector.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.util.written_vars",
"url":26,
"doc":"Returns all variable names written to in this node",
"func":1
},
{
"ref":"opshin.util.NameReadCollector",
"url":26,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"opshin.util.NameReadCollector.step",
"url":26,
"doc":""
},
{
"ref":"opshin.util.NameReadCollector.visit_AnnAssign",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.NameReadCollector.visit_FunctionDef",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.NameReadCollector.visit_Name",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.NameReadCollector.visit_ClassDef",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.NameReadCollector.visit",
"url":26,
"doc":"Visit a node.",
"func":1
},
{
"ref":"opshin.util.read_vars",
"url":26,
"doc":"Returns all variable names read to in this node",
"func":1
},
{
"ref":"opshin.util.all_vars",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.externally_bound_vars",
"url":26,
"doc":"A superset of the variables bound from an outer scope",
"func":1
},
{
"ref":"opshin.util.opshin_name_scheme_compatible_varname",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.OVar",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.OLambda",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.OLet",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.SafeLambda",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.SafeOLambda",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.util.SafeApply",
"url":26,
"doc":"",
"func":1
},
{
"ref":"opshin.prelude",
"url":59,
"doc":""
},
{
"ref":"opshin.prelude.Nothing",
"url":59,
"doc":"Nothing, can be used to signify non-importance of a parameter to a function Example value: Nothing()"
},
{
"ref":"opshin.prelude.Nothing.CONSTR_ID",
"url":59,
"doc":""
},
{
"ref":"opshin.prelude.Token",
"url":59,
"doc":"A token, represented by policy id and token name"
},
{
"ref":"opshin.prelude.Token.policy_id",
"url":59,
"doc":""
},
{
"ref":"opshin.prelude.Token.token_name",
"url":59,
"doc":""
},
{
"ref":"opshin.prelude.Token.CONSTR_ID",
"url":59,
"doc":""
},
{
"ref":"opshin.prelude.Nothing",
"url":59,
"doc":"Nothing, can be used to signify non-importance of a parameter to a function Example value: Nothing()"
},
{
"ref":"opshin.prelude.Nothing.CONSTR_ID",
"url":59,
"doc":""
},
{
"ref":"opshin.prelude.all_tokens_unlocked_from_address",
"url":59,
"doc":"Returns how many tokens of specified type are unlocked from given address",
"func":1
},
{
"ref":"opshin.prelude.all_tokens_locked_at_address_with_datum",
"url":59,
"doc":"Returns how many tokens of specified type are locked at then given address with the specified datum",
"func":1
},
{
"ref":"opshin.prelude.all_tokens_locked_at_address",
"url":59,
"doc":"Returns how many tokens of specified type are locked at the given address",
"func":1
},
{
"ref":"opshin.prelude.resolve_spent_utxo",
"url":59,
"doc":"Returns the UTxO whose spending should be validated",
"func":1
},
{
"ref":"opshin.prelude.resolve_datum_unsafe",
"url":59,
"doc":"Returns the datum attached to a given transaction output, independent of whether it was inlined or embedded. Raises an exception if no datum was attached.",
"func":1
},
{
"ref":"opshin.prelude.resolve_datum",
"url":59,
"doc":"Returns SomeOutputDatum with the datum attached to a given transaction output, independent of whether it was inlined or embedded, if there was an attached datum. Otherwise it returns NoOutputDatum.",
"func":1
},
{
"ref":"opshin.prelude.own_spent_utxo",
"url":59,
"doc":"",
"func":1
},
{
"ref":"opshin.prelude.own_policy_id",
"url":59,
"doc":"obtain the policy id for which this contract can validate minting/burning",
"func":1
},
{
"ref":"opshin.prelude.own_address",
"url":59,
"doc":"Computes the spending script address corresponding to the given policy ID",
"func":1
},
{
"ref":"opshin.prelude.token_present_in_inputs",
"url":59,
"doc":"Returns whether the given token is spent in one of the inputs of the transaction",
"func":1
}
]